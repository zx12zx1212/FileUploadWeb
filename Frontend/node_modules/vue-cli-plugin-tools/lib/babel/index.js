"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const options_1 = require("../options");
const codemod_1 = require("../utils/codemod");
function ensurePluginsProperty(properties, api) {
    const plugins = properties.filter(({ node }) => {
        const { key } = node;
        return key.name === 'plugins';
    });
    if (!plugins.length) {
        const pluginsProperty = api.j.property('init', api.j.identifier('plugins'), api.j.arrayExpression([]));
        properties.at(-1).insertAfter(pluginsProperty);
    }
}
function save(plugins, pluginNodes, pluginNode, api, opts) {
    const exist = pluginNode.length > 0;
    const { libraryName, libraryDirectory, babelPluginOptions = {} } = opts;
    const props = [];
    props.push(api.j.property('init', api.j.identifier('libraryName'), api.j.literal(libraryName)));
    props.push(api.j.property('init', api.j.identifier('libraryDirectory'), api.j.literal(libraryDirectory)));
    props.push(api.j.property('init', api.j.identifier('style'), api.j.literal(codemod_1.styleLang(opts))));
    Object.entries(babelPluginOptions)
        .filter(([k, v]) => {
        return !['libraryName', 'libraryDirectory', 'style'].includes(k);
    })
        .forEach(([k, v]) => {
        props.push(api.j.property('init', api.j.identifier(k), api.j.literal(v)));
    });
    const option = api.j.objectExpression(props);
    if (exist) {
        pluginNode.replaceWith(({ node }) => {
            const { elements } = node;
            elements.splice(1, 1, option);
            return api.j.arrayExpression(elements);
        });
    }
    else {
        const elementArray = [];
        elementArray.push(api.j.literal('import'));
        elementArray.push(option);
        elementArray.push(api.j.literal(libraryName));
        const pluginConf = api.j.arrayExpression(elementArray);
        if (pluginNodes.length > 0) {
            pluginNodes.at(-1).insertAfter(pluginConf);
        }
        else {
            plugins.replaceWith(({ node }) => {
                const { elements } = node.value;
                elements.push(pluginConf);
                return node;
            });
        }
    }
}
const babelTransform = (opts) => {
    return (file, api) => {
        const j = api.jscodeshift;
        const root = j(file.source);
        const identifier = j.Identifier;
        const literal = j.Literal;
        const arrayExpression = j.ArrayExpression;
        const objectExpression = j.ObjectExpression;
        const babelRoot = root.find(j.ObjectExpression, (node) => {
            const { properties } = node;
            return properties.some((p) => identifier.check(p.key) && (p.key.name === 'presets' || p.key.name === 'plugins'));
        });
        const properties = babelRoot.find(api.j.Property, (node) => {
            const { key, value } = node;
            return (identifier.check(key) && arrayExpression.check(value) && (key.name === 'presets' || key.name === 'plugins'));
        });
        ensurePluginsProperty(properties, api);
        const plugins = babelRoot.find(api.j.Property, (node) => {
            const { key, value } = node;
            return identifier.check(key) && arrayExpression.check(value) && key.name === 'plugins';
        });
        const pluginNodes = plugins.find(j.ArrayExpression, (node) => {
            const { elements } = node;
            return elements.some((e) => !arrayExpression.check(e));
        });
        const mergeOpts = { ...options_1.CODE_MOD_OPTIONS, ...opts };
        const { libraryName, remove } = mergeOpts;
        const pluginNode = pluginNodes.filter(({ node }) => {
            const { elements } = node;
            const name = elements[0];
            const options = elements[1];
            let result = literal.check(name) && name.value === 'import' && objectExpression.check(options);
            if (elements.length >= 3) {
                const id = elements[2];
                result = result && literal.check(id) && id.value === libraryName;
            }
            return result;
        });
        if (remove) {
            pluginNode.remove();
        }
        else {
            save(plugins, pluginNodes, pluginNode, api, mergeOpts);
        }
        return root.toSource();
    };
};
exports.default = babelTransform;
