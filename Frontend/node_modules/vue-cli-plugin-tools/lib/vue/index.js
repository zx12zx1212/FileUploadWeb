"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const options_1 = require("../options");
function ensureTranspileDependenciesProperty(properties, api) {
    const dependencies = properties.filter(({ node }) => {
        const { key } = node;
        return key.name === 'transpileDependencies';
    });
    if (!dependencies.length) {
        const pluginsProperty = api.j.property('init', api.j.identifier('transpileDependencies'), api.j.arrayExpression([]));
        properties.at(0).insertBefore(pluginsProperty);
    }
}
function save(dependencies, configNodes, api, opts) {
    const { libraryName, babelConversion } = opts;
    const names = new Set();
    if (babelConversion) {
        names.add(libraryName);
        if (typeof babelConversion === 'string') {
            names.add(babelConversion);
        }
        else if (Array.isArray(babelConversion)) {
            babelConversion.forEach((v) => names.add(v));
        }
    }
    if (configNodes.length > 0) {
        configNodes.forEach(({ node }) => {
            names.delete(node.value);
        });
        names.forEach((value) => {
            configNodes.at(-1).insertAfter(api.j.literal(value));
        });
    }
    else {
        const literals = Array.from(names).map((value) => api.j.literal(value));
        dependencies.replaceWith(({ node }) => {
            const { elements } = node.value;
            elements.push(...literals);
            return node;
        });
    }
}
const vueTransform = (opts) => {
    return (file, api) => {
        const mergeOpts = { ...options_1.CODE_MOD_OPTIONS, ...opts };
        const { libraryName, remove, babelConversion } = mergeOpts;
        if (!babelConversion) {
            return;
        }
        const j = api.jscodeshift;
        const root = j(file.source);
        const assignmentExpression = j.AssignmentExpression;
        const objectExpression = j.ObjectExpression;
        const property = j.Property;
        const identifier = j.Identifier;
        const properties = root.find(property).filter((ast) => {
            return !!(ast.parent &&
                ast.parent.parent &&
                objectExpression.check(ast.parent.node) &&
                assignmentExpression.check(ast.parent.parent.node));
        });
        ensureTranspileDependenciesProperty(properties, api);
        const transpileDependencies = root.find(property).filter(({ node }) => {
            return identifier.check(node.key) && node.key.name === 'transpileDependencies';
        });
        const configNodes = root.find(j.Literal).filter((ast) => {
            if (ast.parent && ast.parent.parent) {
                const pp = ast.parent.parent;
                return (ast.parent &&
                    ast.parent.parent &&
                    property.check(pp.node) &&
                    identifier.check(pp.node.key) &&
                    pp.node.key.name === 'transpileDependencies');
            }
            return false;
        });
        if (remove) {
            configNodes
                .filter(({ node }) => {
                return node.value === libraryName;
            })
                .remove();
        }
        else {
            save(transpileDependencies, configNodes, api, mergeOpts);
        }
        return root.toSource();
    };
};
exports.default = vueTransform;
