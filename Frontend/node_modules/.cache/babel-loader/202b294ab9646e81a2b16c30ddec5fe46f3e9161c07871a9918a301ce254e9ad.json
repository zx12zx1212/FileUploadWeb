{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport PropTypes from '../_util/vue-types';\nimport classNames from '../_util/classNames';\nimport omit from 'omit.js';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\nvar affixProps = {\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: PropTypes.number,\n  offset: PropTypes.number,\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: PropTypes.number,\n  /** 固定状态改变时触发的回调函数 */\n  // onChange?: (affixed?: boolean) => void;\n\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: PropTypes.func.def(getDefaultTarget),\n  prefixCls: PropTypes.string,\n  onChange: PropTypes.func,\n  onTestUpdatePosition: PropTypes.func\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps,\n  emits: ['change', 'testUpdatePosition'],\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = null;\n      if (val) {\n        newTarget = val() || null;\n      }\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    return function () {\n      var _a;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","PropTypes","classNames","omit","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","number","offset","offsetBottom","target","func","def","prefixCls","string","onChange","onTestUpdatePosition","Affix","name","props","emits","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_a","className","restProps","default","_default","call"],"sources":["/Users/lyonxie/Desktop/test/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport PropTypes from '../_util/vue-types';\nimport classNames from '../_util/classNames';\nimport omit from 'omit.js';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nvar affixProps = {\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: PropTypes.number,\n  offset: PropTypes.number,\n\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: PropTypes.number,\n\n  /** 固定状态改变时触发的回调函数 */\n  // onChange?: (affixed?: boolean) => void;\n\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: PropTypes.func.def(getDefaultTarget),\n  prefixCls: PropTypes.string,\n  onChange: PropTypes.func,\n  onTestUpdatePosition: PropTypes.func\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps,\n  emits: ['change', 'testUpdatePosition'],\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = null;\n\n      if (val) {\n        newTarget = val() || null;\n      }\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}