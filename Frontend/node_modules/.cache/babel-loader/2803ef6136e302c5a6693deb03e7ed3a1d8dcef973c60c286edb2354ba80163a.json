{"ast":null,"code":"import { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport PropTypes from './vue-types';\nimport Portal from './Portal';\nimport { defineComponent, shallowRef, watch, onMounted, onBeforeUnmount, onUpdated, nextTick, computed } from 'vue';\nimport canUseDom from './canUseDom';\nimport raf from './raf';\nimport { booleanType } from './type';\nimport useScrollLocker from './hooks/useScrollLocker';\nlet openCount = 0;\nconst supportDom = canUseDom();\n/** @private Test usage only */\nexport function getOpenCount() {\n  return process.env.NODE_ENV === 'test' ? openCount : 0;\n}\nconst getParent = getContainer => {\n  if (!supportDom) {\n    return null;\n  }\n  if (getContainer) {\n    if (typeof getContainer === 'string') {\n      return document.querySelectorAll(getContainer)[0];\n    }\n    if (typeof getContainer === 'function') {\n      return getContainer();\n    }\n    if (typeof getContainer === 'object' && getContainer instanceof window.HTMLElement) {\n      return getContainer;\n    }\n  }\n  return document.body;\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'PortalWrapper',\n  inheritAttrs: false,\n  props: {\n    wrapperClassName: String,\n    forceRender: {\n      type: Boolean,\n      default: undefined\n    },\n    getContainer: PropTypes.any,\n    visible: {\n      type: Boolean,\n      default: undefined\n    },\n    autoLock: booleanType(),\n    didUpdate: Function\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const container = shallowRef();\n    const componentRef = shallowRef();\n    const rafId = shallowRef();\n    const triggerUpdate = shallowRef(1);\n    const defaultContainer = canUseDom() && document.createElement('div');\n    const removeCurrentContainer = () => {\n      var _a, _b;\n      // Portal will remove from `parentNode`.\n      // Let's handle this again to avoid refactor issue.\n      if (container.value === defaultContainer) {\n        (_b = (_a = container.value) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);\n      }\n      container.value = null;\n    };\n    let parent = null;\n    const attachToParent = function () {\n      let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (force || container.value && !container.value.parentNode) {\n        parent = getParent(props.getContainer);\n        if (parent) {\n          parent.appendChild(container.value);\n          return true;\n        }\n        return false;\n      }\n      return true;\n    };\n    const getContainer = () => {\n      if (!supportDom) {\n        return null;\n      }\n      if (!container.value) {\n        container.value = defaultContainer;\n        attachToParent(true);\n      }\n      setWrapperClassName();\n      return container.value;\n    };\n    const setWrapperClassName = () => {\n      const {\n        wrapperClassName\n      } = props;\n      if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {\n        container.value.className = wrapperClassName;\n      }\n    };\n    onUpdated(() => {\n      setWrapperClassName();\n      attachToParent();\n    });\n    useScrollLocker(computed(() => {\n      return props.autoLock && props.visible && canUseDom() && (container.value === document.body || container.value === defaultContainer);\n    }));\n    onMounted(() => {\n      let init = false;\n      watch([() => props.visible, () => props.getContainer], (_ref2, _ref3) => {\n        let [visible, getContainer] = _ref2;\n        let [prevVisible, prevGetContainer] = _ref3;\n        // Update count\n        if (supportDom) {\n          parent = getParent(props.getContainer);\n          if (parent === document.body) {\n            if (visible && !prevVisible) {\n              openCount += 1;\n            } else if (init) {\n              openCount -= 1;\n            }\n          }\n        }\n        if (init) {\n          // Clean up container if needed\n          const getContainerIsFunc = typeof getContainer === 'function' && typeof prevGetContainer === 'function';\n          if (getContainerIsFunc ? getContainer.toString() !== prevGetContainer.toString() : getContainer !== prevGetContainer) {\n            removeCurrentContainer();\n          }\n        }\n        init = true;\n      }, {\n        immediate: true,\n        flush: 'post'\n      });\n      nextTick(() => {\n        if (!attachToParent()) {\n          rafId.value = raf(() => {\n            triggerUpdate.value += 1;\n          });\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      const {\n        visible\n      } = props;\n      if (supportDom && parent === document.body) {\n        // 离开时不会 render， 导到离开时数值不变，改用 func 。。\n        openCount = visible && openCount ? openCount - 1 : openCount;\n      }\n      removeCurrentContainer();\n      raf.cancel(rafId.value);\n    });\n    return () => {\n      const {\n        forceRender,\n        visible\n      } = props;\n      let portal = null;\n      const childProps = {\n        getOpenCount: () => openCount,\n        getContainer\n      };\n      if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {\n        portal = _createVNode(Portal, {\n          \"getContainer\": getContainer,\n          \"ref\": componentRef,\n          \"didUpdate\": props.didUpdate\n        }, {\n          default: () => {\n            var _a;\n            return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, childProps);\n          }\n        });\n      }\n      return portal;\n    };\n  }\n});","map":{"version":3,"names":["createVNode","_createVNode","resolveDirective","_resolveDirective","PropTypes","Portal","defineComponent","shallowRef","watch","onMounted","onBeforeUnmount","onUpdated","nextTick","computed","canUseDom","raf","booleanType","useScrollLocker","openCount","supportDom","getOpenCount","process","env","NODE_ENV","getParent","getContainer","document","querySelectorAll","window","HTMLElement","body","compatConfig","MODE","name","inheritAttrs","props","wrapperClassName","String","forceRender","type","Boolean","default","undefined","any","visible","autoLock","didUpdate","Function","setup","_ref","slots","container","componentRef","rafId","triggerUpdate","defaultContainer","createElement","removeCurrentContainer","_a","_b","value","parentNode","removeChild","parent","attachToParent","force","arguments","length","appendChild","setWrapperClassName","className","init","_ref2","_ref3","prevVisible","prevGetContainer","getContainerIsFunc","toString","immediate","flush","cancel","portal","childProps","call"],"sources":["/Users/lyonxie/Desktop/Frontend/node_modules/ant-design-vue/es/_util/PortalWrapper.js"],"sourcesContent":["import { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport PropTypes from './vue-types';\nimport Portal from './Portal';\nimport { defineComponent, shallowRef, watch, onMounted, onBeforeUnmount, onUpdated, nextTick, computed } from 'vue';\nimport canUseDom from './canUseDom';\nimport raf from './raf';\nimport { booleanType } from './type';\nimport useScrollLocker from './hooks/useScrollLocker';\nlet openCount = 0;\nconst supportDom = canUseDom();\n/** @private Test usage only */\nexport function getOpenCount() {\n  return process.env.NODE_ENV === 'test' ? openCount : 0;\n}\nconst getParent = getContainer => {\n  if (!supportDom) {\n    return null;\n  }\n  if (getContainer) {\n    if (typeof getContainer === 'string') {\n      return document.querySelectorAll(getContainer)[0];\n    }\n    if (typeof getContainer === 'function') {\n      return getContainer();\n    }\n    if (typeof getContainer === 'object' && getContainer instanceof window.HTMLElement) {\n      return getContainer;\n    }\n  }\n  return document.body;\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'PortalWrapper',\n  inheritAttrs: false,\n  props: {\n    wrapperClassName: String,\n    forceRender: {\n      type: Boolean,\n      default: undefined\n    },\n    getContainer: PropTypes.any,\n    visible: {\n      type: Boolean,\n      default: undefined\n    },\n    autoLock: booleanType(),\n    didUpdate: Function\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const container = shallowRef();\n    const componentRef = shallowRef();\n    const rafId = shallowRef();\n    const triggerUpdate = shallowRef(1);\n    const defaultContainer = canUseDom() && document.createElement('div');\n    const removeCurrentContainer = () => {\n      var _a, _b;\n      // Portal will remove from `parentNode`.\n      // Let's handle this again to avoid refactor issue.\n      if (container.value === defaultContainer) {\n        (_b = (_a = container.value) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);\n      }\n      container.value = null;\n    };\n    let parent = null;\n    const attachToParent = function () {\n      let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (force || container.value && !container.value.parentNode) {\n        parent = getParent(props.getContainer);\n        if (parent) {\n          parent.appendChild(container.value);\n          return true;\n        }\n        return false;\n      }\n      return true;\n    };\n    const getContainer = () => {\n      if (!supportDom) {\n        return null;\n      }\n      if (!container.value) {\n        container.value = defaultContainer;\n        attachToParent(true);\n      }\n      setWrapperClassName();\n      return container.value;\n    };\n    const setWrapperClassName = () => {\n      const {\n        wrapperClassName\n      } = props;\n      if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {\n        container.value.className = wrapperClassName;\n      }\n    };\n    onUpdated(() => {\n      setWrapperClassName();\n      attachToParent();\n    });\n    useScrollLocker(computed(() => {\n      return props.autoLock && props.visible && canUseDom() && (container.value === document.body || container.value === defaultContainer);\n    }));\n    onMounted(() => {\n      let init = false;\n      watch([() => props.visible, () => props.getContainer], (_ref2, _ref3) => {\n        let [visible, getContainer] = _ref2;\n        let [prevVisible, prevGetContainer] = _ref3;\n        // Update count\n        if (supportDom) {\n          parent = getParent(props.getContainer);\n          if (parent === document.body) {\n            if (visible && !prevVisible) {\n              openCount += 1;\n            } else if (init) {\n              openCount -= 1;\n            }\n          }\n        }\n        if (init) {\n          // Clean up container if needed\n          const getContainerIsFunc = typeof getContainer === 'function' && typeof prevGetContainer === 'function';\n          if (getContainerIsFunc ? getContainer.toString() !== prevGetContainer.toString() : getContainer !== prevGetContainer) {\n            removeCurrentContainer();\n          }\n        }\n        init = true;\n      }, {\n        immediate: true,\n        flush: 'post'\n      });\n      nextTick(() => {\n        if (!attachToParent()) {\n          rafId.value = raf(() => {\n            triggerUpdate.value += 1;\n          });\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      const {\n        visible\n      } = props;\n      if (supportDom && parent === document.body) {\n        // 离开时不会 render， 导到离开时数值不变，改用 func 。。\n        openCount = visible && openCount ? openCount - 1 : openCount;\n      }\n      removeCurrentContainer();\n      raf.cancel(rafId.value);\n    });\n    return () => {\n      const {\n        forceRender,\n        visible\n      } = props;\n      let portal = null;\n      const childProps = {\n        getOpenCount: () => openCount,\n        getContainer\n      };\n      if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {\n        portal = _createVNode(Portal, {\n          \"getContainer\": getContainer,\n          \"ref\": componentRef,\n          \"didUpdate\": props.didUpdate\n        }, {\n          default: () => {\n            var _a;\n            return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, childProps);\n          }\n        });\n      }\n      return portal;\n    };\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}