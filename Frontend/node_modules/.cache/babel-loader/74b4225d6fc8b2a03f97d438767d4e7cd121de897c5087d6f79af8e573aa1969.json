{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { toArray } from './typeUtil';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\n\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(function (path) {\n    return matchNamePath(path, namePath);\n  });\n}\nfunction isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\n\nfunction internalSetValues(store, values) {\n  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _extends({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(function (key) {\n    var prevValue = newStore[key];\n    var value = values[key]; // If both are object (but target is not array), we use recursion to set deep value\n\n    var recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce(function (current, newStore) {\n    return internalSetValues(current, newStore);\n  }, store);\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every(function (nameUnit, i) {\n    return changedNamePath[i] === nameUnit;\n  });\n}","map":{"version":3,"names":["_extends","_toConsumableArray","_typeof","toArray","getNamePath","path","containsNamePath","namePathList","namePath","some","matchNamePath","isObject","obj","Object","getPrototypeOf","prototype","internalSetValues","store","values","newStore","Array","isArray","keys","forEach","key","prevValue","value","recursive","setValues","_len","arguments","length","restValues","_key","reduce","current","changedNamePath","every","nameUnit","i"],"sources":["/Users/lyonxie/Desktop/Frontend/node_modules/ant-design-vue/es/form/utils/valueUtil.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { toArray } from './typeUtil';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\n\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(function (path) {\n    return matchNamePath(path, namePath);\n  });\n}\n\nfunction isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\n\n\nfunction internalSetValues(store, values) {\n  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _extends({}, store);\n\n  if (!values) {\n    return newStore;\n  }\n\n  Object.keys(values).forEach(function (key) {\n    var prevValue = newStore[key];\n    var value = values[key]; // If both are object (but target is not array), we use recursion to set deep value\n\n    var recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\n\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n\n  return restValues.reduce(function (current, newStore) {\n    return internalSetValues(current, newStore);\n  }, store);\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n\n  return namePath.every(function (nameUnit, i) {\n    return changedNamePath[i] === nameUnit;\n  });\n}"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAOC,kBAAkB,MAAM,8CAA8C;AAC7E,OAAOC,OAAO,MAAM,mCAAmC;AACvD,SAASC,OAAO,QAAQ,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,WAAWA,CAACC,IAAI,EAAE;EAChC,OAAOF,OAAO,CAACE,IAAI,CAAC;AACtB;AACA,OAAO,SAASC,gBAAgBA,CAACC,YAAY,EAAEC,QAAQ,EAAE;EACvD,OAAOD,YAAY,IAAIA,YAAY,CAACE,IAAI,CAAC,UAAUJ,IAAI,EAAE;IACvD,OAAOK,aAAa,CAACL,IAAI,EAAEG,QAAQ,CAAC;EACtC,CAAC,CAAC;AACJ;AAEA,SAASG,QAAQA,CAACC,GAAG,EAAE;EACrB,OAAOV,OAAO,CAACU,GAAG,CAAC,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,IAAIC,MAAM,CAACC,cAAc,CAACF,GAAG,CAAC,KAAKC,MAAM,CAACE,SAAS;AACrG;AACA;AACA;AACA;AACA;;AAGA,SAASC,iBAAiBA,CAACC,KAAK,EAAEC,MAAM,EAAE;EACxC,IAAIC,QAAQ,GAAGC,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,GAAGhB,kBAAkB,CAACgB,KAAK,CAAC,GAAGjB,QAAQ,CAAC,CAAC,CAAC,EAAEiB,KAAK,CAAC;EAErF,IAAI,CAACC,MAAM,EAAE;IACX,OAAOC,QAAQ;EACjB;EAEAN,MAAM,CAACS,IAAI,CAACJ,MAAM,CAAC,CAACK,OAAO,CAAC,UAAUC,GAAG,EAAE;IACzC,IAAIC,SAAS,GAAGN,QAAQ,CAACK,GAAG,CAAC;IAC7B,IAAIE,KAAK,GAAGR,MAAM,CAACM,GAAG,CAAC,CAAC,CAAC;;IAEzB,IAAIG,SAAS,GAAGhB,QAAQ,CAACc,SAAS,CAAC,IAAId,QAAQ,CAACe,KAAK,CAAC;IACtDP,QAAQ,CAACK,GAAG,CAAC,GAAGG,SAAS,GAAGX,iBAAiB,CAACS,SAAS,EAAEC,KAAK,IAAI,CAAC,CAAC,CAAC,GAAGA,KAAK;EAC/E,CAAC,CAAC;EACF,OAAOP,QAAQ;AACjB;AAEA,OAAO,SAASS,SAASA,CAACX,KAAK,EAAE;EAC/B,KAAK,IAAIY,IAAI,GAAGC,SAAS,CAACC,MAAM,EAAEC,UAAU,GAAG,IAAIZ,KAAK,CAACS,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEI,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,EAAEI,IAAI,EAAE,EAAE;IAChHD,UAAU,CAACC,IAAI,GAAG,CAAC,CAAC,GAAGH,SAAS,CAACG,IAAI,CAAC;EACxC;EAEA,OAAOD,UAAU,CAACE,MAAM,CAAC,UAAUC,OAAO,EAAEhB,QAAQ,EAAE;IACpD,OAAOH,iBAAiB,CAACmB,OAAO,EAAEhB,QAAQ,CAAC;EAC7C,CAAC,EAAEF,KAAK,CAAC;AACX;AACA,OAAO,SAASP,aAAaA,CAACF,QAAQ,EAAE4B,eAAe,EAAE;EACvD,IAAI,CAAC5B,QAAQ,IAAI,CAAC4B,eAAe,IAAI5B,QAAQ,CAACuB,MAAM,KAAKK,eAAe,CAACL,MAAM,EAAE;IAC/E,OAAO,KAAK;EACd;EAEA,OAAOvB,QAAQ,CAAC6B,KAAK,CAAC,UAAUC,QAAQ,EAAEC,CAAC,EAAE;IAC3C,OAAOH,eAAe,CAACG,CAAC,CAAC,KAAKD,QAAQ;EACxC,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}