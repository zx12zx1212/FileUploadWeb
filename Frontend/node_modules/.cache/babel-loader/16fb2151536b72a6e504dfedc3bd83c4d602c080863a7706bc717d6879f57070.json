{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { computed, defineComponent, onBeforeUnmount, onMounted, shallowRef, watch } from 'vue';\nimport { getStyleStr, getPixelRatio, rotateWatermark, reRendering } from './utils';\nimport { arrayType, objectType, someType, withInstall } from '../_util/type';\nimport { useMutationObserver } from '../_util/hooks/_vueuse/useMutationObserver';\nimport { initDefaultProps } from '../_util/props-util';\nimport { useToken } from '../theme/internal';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nexport const watermarkProps = () => ({\n  zIndex: Number,\n  rotate: Number,\n  width: Number,\n  height: Number,\n  image: String,\n  content: someType([String, Array]),\n  font: objectType(),\n  rootClassName: String,\n  gap: arrayType(),\n  offset: arrayType()\n});\nconst Watermark = defineComponent({\n  name: 'AWatermark',\n  inheritAttrs: false,\n  props: initDefaultProps(watermarkProps(), {\n    zIndex: 9,\n    rotate: -22,\n    font: {},\n    gap: [100, 100]\n  }),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const [, token] = useToken();\n    const containerRef = shallowRef();\n    const watermarkRef = shallowRef();\n    const stopObservation = shallowRef(false);\n    const gapX = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapY = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontSize) !== null && _b !== void 0 ? _b : token.value.fontSizeLG;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontWeight) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontStyle) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontFamily) !== null && _b !== void 0 ? _b : 'sans-serif';\n    });\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : token.value.colorFill;\n    });\n    const markStyle = computed(() => {\n      var _a;\n      const markStyle = {\n        zIndex: (_a = props.zIndex) !== null && _a !== void 0 ? _a : 9,\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        backgroundRepeat: 'repeat'\n      };\n      /** Calculate the style of the offset */\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    });\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = undefined;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute('style', getStyleStr(_extends(_extends({}, markStyle.value), {\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`\n        })));\n        (_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.value);\n        // Delayed execution\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    /**\n     * Get the width and height of the watermark. The default values are as follows\n     * Image: [120, 64]; Content: It's calculated by content;\n     */\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      const content = props.content;\n      const image = props.image;\n      const width = props.width;\n      const height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = Array.isArray(content) ? content : [content];\n        const widths = contents.map(item => ctx.measureText(item).width);\n        defaultWidth = Math.ceil(Math.max(...widths));\n        defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n    };\n    const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n      const ratio = getPixelRatio();\n      const content = props.content;\n      const mergedFontSize = Number(fontSize.value) * ratio;\n      ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;\n      ctx.fillStyle = color.value;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.translate(drawWidth / 2, 0);\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n      });\n    };\n    const renderWatermark = () => {\n      var _a;\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const image = props.image;\n      const rotate = (_a = props.rotate) !== null && _a !== void 0 ? _a : -22;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement('div');\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight] = getMarkSize(ctx);\n        const canvasWidth = (gapX.value + markWidth) * ratio;\n        const canvasHeight = (gapY.value + markHeight) * ratio;\n        canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n        canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n        const drawX = gapX.value * ratio / 2;\n        const drawY = gapY.value * ratio / 2;\n        const drawWidth = markWidth * ratio;\n        const drawHeight = markHeight * ratio;\n        const rotateX = (drawWidth + gapX.value * ratio) / 2;\n        const rotateY = (drawHeight + gapY.value * ratio) / 2;\n        /** Alternate drawing parameters */\n        const alternateDrawX = drawX + canvasWidth;\n        const alternateDrawY = drawY + canvasHeight;\n        const alternateRotateX = rotateX + canvasWidth;\n        const alternateRotateY = rotateY + canvasHeight;\n        ctx.save();\n        rotateWatermark(ctx, rotateX, rotateY, rotate);\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n            /** Draw interleaved pictures after rotation */\n            ctx.restore();\n            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n            ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n            appendWatermark(canvas.toDataURL(), markWidth);\n          };\n          img.crossOrigin = 'anonymous';\n          img.referrerPolicy = 'no-referrer';\n          img.src = image;\n        } else {\n          fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n          /** Fill the interleaved text after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => [props, token.value.colorFill, token.value.fontSizeLG], () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: 'post'\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true,\n      subtree: true,\n      childList: true,\n      attributeFilter: ['style', 'class']\n    });\n    return () => {\n      var _a;\n      return _createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"ref\": containerRef,\n        \"class\": [attrs.class, props.rootClassName],\n        \"style\": [{\n          position: 'relative'\n        }, attrs.style]\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);\n    };\n  }\n});\nexport default withInstall(Watermark);","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","computed","defineComponent","onBeforeUnmount","onMounted","shallowRef","watch","getStyleStr","getPixelRatio","rotateWatermark","reRendering","arrayType","objectType","someType","withInstall","useMutationObserver","initDefaultProps","useToken","BaseSize","FontGap","watermarkProps","zIndex","Number","rotate","width","height","image","String","content","Array","font","rootClassName","gap","offset","Watermark","name","inheritAttrs","props","setup","_ref","slots","attrs","token","containerRef","watermarkRef","stopObservation","gapX","_a","_b","gapY","gapXCenter","value","gapYCenter","offsetLeft","offsetTop","fontSize","fontSizeLG","fontWeight","fontStyle","fontFamily","color","colorFill","markStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","destroyWatermark","remove","undefined","appendWatermark","base64Url","markWidth","setAttribute","backgroundImage","backgroundSize","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","contents","isArray","widths","map","item","Math","ceil","max","length","fillTexts","drawX","drawY","drawWidth","drawHeight","ratio","mergedFontSize","fillStyle","textAlign","textBaseline","translate","forEach","index","fillText","renderWatermark","canvas","document","createElement","getContext","markHeight","canvasWidth","canvasHeight","rotateX","rotateY","alternateDrawX","alternateDrawY","alternateRotateX","alternateRotateY","save","img","Image","onload","drawImage","restore","toDataURL","crossOrigin","referrerPolicy","src","deep","flush","onMutate","mutations","mutation","attributes","subtree","childList","attributeFilter","class","style","default","call"],"sources":["/Users/lyonxie/Desktop/Frontend/node_modules/ant-design-vue/es/watermark/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { computed, defineComponent, onBeforeUnmount, onMounted, shallowRef, watch } from 'vue';\nimport { getStyleStr, getPixelRatio, rotateWatermark, reRendering } from './utils';\nimport { arrayType, objectType, someType, withInstall } from '../_util/type';\nimport { useMutationObserver } from '../_util/hooks/_vueuse/useMutationObserver';\nimport { initDefaultProps } from '../_util/props-util';\nimport { useToken } from '../theme/internal';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nexport const watermarkProps = () => ({\n  zIndex: Number,\n  rotate: Number,\n  width: Number,\n  height: Number,\n  image: String,\n  content: someType([String, Array]),\n  font: objectType(),\n  rootClassName: String,\n  gap: arrayType(),\n  offset: arrayType()\n});\nconst Watermark = defineComponent({\n  name: 'AWatermark',\n  inheritAttrs: false,\n  props: initDefaultProps(watermarkProps(), {\n    zIndex: 9,\n    rotate: -22,\n    font: {},\n    gap: [100, 100]\n  }),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const [, token] = useToken();\n    const containerRef = shallowRef();\n    const watermarkRef = shallowRef();\n    const stopObservation = shallowRef(false);\n    const gapX = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapY = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontSize) !== null && _b !== void 0 ? _b : token.value.fontSizeLG;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontWeight) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontStyle) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontFamily) !== null && _b !== void 0 ? _b : 'sans-serif';\n    });\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : token.value.colorFill;\n    });\n    const markStyle = computed(() => {\n      var _a;\n      const markStyle = {\n        zIndex: (_a = props.zIndex) !== null && _a !== void 0 ? _a : 9,\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        backgroundRepeat: 'repeat'\n      };\n      /** Calculate the style of the offset */\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    });\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = undefined;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute('style', getStyleStr(_extends(_extends({}, markStyle.value), {\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`\n        })));\n        (_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.value);\n        // Delayed execution\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    /**\n     * Get the width and height of the watermark. The default values are as follows\n     * Image: [120, 64]; Content: It's calculated by content;\n     */\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      const content = props.content;\n      const image = props.image;\n      const width = props.width;\n      const height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = Array.isArray(content) ? content : [content];\n        const widths = contents.map(item => ctx.measureText(item).width);\n        defaultWidth = Math.ceil(Math.max(...widths));\n        defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n    };\n    const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n      const ratio = getPixelRatio();\n      const content = props.content;\n      const mergedFontSize = Number(fontSize.value) * ratio;\n      ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;\n      ctx.fillStyle = color.value;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.translate(drawWidth / 2, 0);\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n      });\n    };\n    const renderWatermark = () => {\n      var _a;\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const image = props.image;\n      const rotate = (_a = props.rotate) !== null && _a !== void 0 ? _a : -22;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement('div');\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight] = getMarkSize(ctx);\n        const canvasWidth = (gapX.value + markWidth) * ratio;\n        const canvasHeight = (gapY.value + markHeight) * ratio;\n        canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n        canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n        const drawX = gapX.value * ratio / 2;\n        const drawY = gapY.value * ratio / 2;\n        const drawWidth = markWidth * ratio;\n        const drawHeight = markHeight * ratio;\n        const rotateX = (drawWidth + gapX.value * ratio) / 2;\n        const rotateY = (drawHeight + gapY.value * ratio) / 2;\n        /** Alternate drawing parameters */\n        const alternateDrawX = drawX + canvasWidth;\n        const alternateDrawY = drawY + canvasHeight;\n        const alternateRotateX = rotateX + canvasWidth;\n        const alternateRotateY = rotateY + canvasHeight;\n        ctx.save();\n        rotateWatermark(ctx, rotateX, rotateY, rotate);\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n            /** Draw interleaved pictures after rotation */\n            ctx.restore();\n            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n            ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n            appendWatermark(canvas.toDataURL(), markWidth);\n          };\n          img.crossOrigin = 'anonymous';\n          img.referrerPolicy = 'no-referrer';\n          img.src = image;\n        } else {\n          fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n          /** Fill the interleaved text after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => [props, token.value.colorFill, token.value.fontSizeLG], () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: 'post'\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true,\n      subtree: true,\n      childList: true,\n      attributeFilter: ['style', 'class']\n    });\n    return () => {\n      var _a;\n      return _createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"ref\": containerRef,\n        \"class\": [attrs.class, props.rootClassName],\n        \"style\": [{\n          position: 'relative'\n        }, attrs.style]\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);\n    };\n  }\n});\nexport default withInstall(Watermark);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}